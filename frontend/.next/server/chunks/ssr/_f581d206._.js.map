{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG1B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,4DACA;QAED,GAAG,KAAK;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QAAI,KAAK;QAAK,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QAAa,GAAG,KAAK;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,qMAAA,CAAA,aAAgB,AAAD,EAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,8OAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { z } from 'zod'\nimport { generateFinancialInsights } from '@/ai/flows/generate-financial-insights'\nimport { generateInvoiceFromText } from '@/ai/flows/generate-invoice-from-text'\nimport { calculateTax } from '@/ai/flows/calculate-tax'\nimport { invoiceSchema, clientSchema } from '@/lib/types'\nimport { planLimits } from '@/lib/subscriptions';\nimport { cookies } from 'next/headers'\nimport { redirect } from 'next/navigation'\nimport { revalidatePath } from 'next/cache'\n\nconst API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:8080/api';\n\nconst loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1, 'Password is required')\n})\n\n// --- Helper function for API calls ---\nasync function apiFetch(url: string, options: RequestInit = {}) {\n  const sessionToken = cookies().get('session')?.value;\n  try {\n    const res = await fetch(`${API_BASE_URL}${url}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...(sessionToken && { 'Authorization': `Bearer ${sessionToken}` }),\n        ...options.headers,\n      },\n    });\n\n    if (!res.ok) {\n      const errorBody = await res.json().catch(() => ({ message: `Request failed with status ${res.status}` }));\n      // For 403 Forbidden, we want to show a specific message from the API\n      if (res.status === 403) {\n          throw new Error(errorBody.message || 'You do not have permission to perform this action. Please upgrade your plan.');\n      }\n      throw new Error(errorBody.message || 'An API error occurred');\n    }\n\n    if (res.status === 204) { // No Content\n        return null;\n    }\n\n    return await res.json();\n  } catch (error) {\n    console.error(`API Error fetching ${url}:`, error);\n    const message = error instanceof Error ? error.message : 'An unknown network error occurred';\n    throw new Error(message);\n  }\n}\n\n\nexport async function loginAction(data: z.infer<typeof loginSchema>) {\n  const parsedData = loginSchema.safeParse(data);\n  if (!parsedData.success) {\n      return { success: false, error: \"Invalid data provided.\"}\n  }\n\n  const { email, password } = parsedData.data;\n\n  // Mock authentication logic - in a real app, this would call a /login API endpoint\n  // that validates hashed passwords.\n  if (email === 'user@example.com' && password === 'password') {\n    // For this demo, we use the user's email as their session \"token\".\n    // This allows the backend to identify the user for each request.\n    cookies().set('session', email, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      path: '/',\n      // Removed maxAge to make it a session cookie\n    })\n    return { success: true }\n  } else {\n    return { success: false, error: 'Invalid credentials.' }\n  }\n}\n\nexport async function logoutAction() {\n  cookies().delete('session')\n  redirect('/login')\n}\n\n// --- User Actions ---\nexport async function getUserAction() {\n  try {\n    const user = await apiFetch('/users/me');\n    return { success: true, data: user };\n  } catch (error) {\n    return { success: false, error: 'User not found.' };\n  }\n}\n\n\n// --- Invoice Actions ---\n\nexport async function getInvoicesAction(params?: { clientId?: string }) {\n  try {\n    const url = params?.clientId ? `/invoices?clientId=${params.clientId}` : '/invoices';\n    const invoices = await apiFetch(url);\n    return { success: true, data: invoices };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to fetch invoices.' };\n  }\n}\n\nexport async function createInvoiceAction(data: z.infer<typeof invoiceSchema>) {\n  const parsedData = invoiceSchema.safeParse(data);\n  if (!parsedData.success) {\n    return { success: false, error: 'Invalid data provided.' };\n  }\n  \n  try {\n    const subtotal = parsedData.data.lineItems.reduce((sum, item) => sum + item.quantity * item.rate, 0);\n    const tax = parsedData.data.tax || 0;\n    const total = subtotal + tax;\n\n    const newInvoiceData = { ...parsedData.data, subtotal, tax, total };\n    \n    // The backend will now check the user's plan and invoice count before creating.\n    await apiFetch('/invoices', {\n      method: 'POST',\n      body: JSON.stringify(newInvoiceData),\n    });\n    \n    revalidatePath('/dashboard/invoices');\n    revalidatePath('/dashboard/payments');\n    revalidatePath('/dashboard/settings'); // To update usage display\n    return { success: true, message: 'Invoice created successfully!' };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to create invoice.' };\n  }\n}\n\nexport async function getInvoiceByIdAction(id: string) {\n  try {\n    const invoice = await apiFetch(`/invoices/${id}`);\n    return { success: true, data: invoice };\n  } catch (error) {\n    return { success: false, error: 'Invoice not found.' };\n  }\n}\n\nexport async function updateInvoiceAction(id: string, data: z.infer<typeof invoiceSchema>) {\n  const parsedData = invoiceSchema.safeParse(data);\n  if (!parsedData.success) {\n    return { success: false, error: 'Invalid data provided.' };\n  }\n\n  try {\n    const subtotal = parsedData.data.lineItems.reduce((sum, item) => sum + item.quantity * item.rate, 0);\n    const tax = parsedData.data.tax || 0;\n    const total = subtotal + tax;\n\n    const updatedInvoiceData = { ...parsedData.data, subtotal, tax, total };\n\n    await apiFetch(`/invoices/${id}`, {\n      method: 'PUT',\n      body: JSON.stringify(updatedInvoiceData),\n    });\n\n    revalidatePath('/dashboard/invoices');\n    revalidatePath(`/dashboard/invoices/${id}`);\n    revalidatePath(`/dashboard/invoices/${id}/edit`);\n    revalidatePath('/dashboard/payments');\n    return { success: true, message: `Invoice ${data.invoiceNumber} updated successfully!` };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to update invoice.' };\n  }\n}\n\nexport async function deleteInvoiceAction(id: string) {\n  try {\n    await apiFetch(`/invoices/${id}`, { method: 'DELETE' });\n    revalidatePath('/dashboard/invoices');\n    revalidatePath('/dashboard/payments');\n    return { success: true, message: 'Invoice deleted successfully!' };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to delete invoice.' };\n  }\n}\n\nexport async function updateInvoiceStatusAction(id: string, status: 'paid' | 'pending' | 'overdue') {\n  try {\n    await apiFetch(`/invoices/${id}/status`, {\n      method: 'PUT',\n      body: JSON.stringify({ status }),\n    });\n    revalidatePath('/dashboard/invoices');\n    revalidatePath(`/dashboard/invoices/${id}`);\n    revalidatePath('/dashboard'); // For the stats cards\n    revalidatePath('/dashboard/payments');\n    return { success: true, message: `Invoice status updated to ${status}.` };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to update invoice status.' };\n  }\n}\n\nexport async function sendInvoiceReminderAction(invoiceId: string) {\n  try {\n    const result = await apiFetch(`/invoices/${invoiceId}/remind`, { method: 'POST' });\n    return { success: true, message: result.message || 'Reminder sent successfully!' };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to send reminder.' };\n  }\n}\n\n// --- Client Actions ---\n\nexport async function getClientsAction() {\n    try {\n        const clients = await apiFetch('/clients');\n        return { success: true, data: clients };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to fetch clients.' };\n    }\n}\n\nexport async function getClientByIdAction(id: string) {\n    try {\n        const client = await apiFetch(`/clients/${id}`);\n        return { success: true, data: client };\n    } catch (error) {\n        return { success: false, error: 'Client not found.' };\n    }\n}\n\nexport async function createClientAction(data: z.infer<typeof clientSchema>) {\n    const parsedData = clientSchema.safeParse(data);\n    if (!parsedData.success) {\n        return { success: false, error: \"Invalid data provided.\"}\n    }\n    try {\n        await apiFetch('/clients', {\n            method: 'POST',\n            body: JSON.stringify(parsedData.data),\n        });\n        revalidatePath('/dashboard/clients');\n        return { success: true, message: 'Client created successfully!' };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to create client.' };\n    }\n}\n\nexport async function updateClientAction(id: string, data: z.infer<typeof clientSchema>) {\n    const parsedData = clientSchema.safeParse(data);\n    if (!parsedData.success) {\n        return { success: false, error: 'Invalid data provided.'}\n    }\n    try {\n        await apiFetch(`/clients/${id}`, {\n            method: 'PUT',\n            body: JSON.stringify(parsedData.data),\n        });\n        revalidatePath('/dashboard/clients');\n        revalidatePath(`/dashboard/clients/${id}`);\n        revalidatePath(`/dashboard/clients/${id}/edit`);\n        return { success: true, message: `Client ${data.name} updated successfully!` };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to update client.' };\n    }\n}\n\nexport async function deleteClientAction(id: string) {\n    try {\n        await apiFetch(`/clients/${id}`, { method: 'DELETE' });\n        revalidatePath('/dashboard/clients');\n        return { success: true, message: 'Client deleted successfully!' };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to delete client.' };\n    }\n}\n\nconst noteFormSchema = z.object({\n  content: z.string().min(1, 'Note content cannot be empty.'),\n});\n\nexport async function addClientNoteAction(clientId: string, data: z.infer<typeof noteFormSchema>) {\n  const parsedData = noteFormSchema.safeParse(data);\n  if (!parsedData.success) {\n    return { success: false, error: 'Invalid data provided.' };\n  }\n  try {\n    const updatedClient = await apiFetch(`/clients/${clientId}/notes`, {\n      method: 'POST',\n      body: JSON.stringify(parsedData.data),\n    });\n    revalidatePath(`/dashboard/clients/${clientId}`);\n    return { success: true, message: 'Note added successfully!', data: updatedClient };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Failed to add note.' };\n  }\n}\n\n// --- Payment Actions ---\n\nexport async function getPaymentsAction() {\n    try {\n        const payments = await apiFetch('/payments');\n        return { success: true, data: payments };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to fetch payments.' };\n    }\n}\n\n// --- Stripe / Subscription Actions ---\nexport async function createPaymentIntentAction(amount: number, currency: string) {\n    try {\n        const result = await apiFetch('/stripe/create-payment-intent', {\n            method: 'POST',\n            body: JSON.stringify({ amount, currency }),\n        });\n        return { success: true, clientSecret: result.clientSecret };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to create payment intent.' };\n    }\n}\n\nexport async function confirmStripePaymentAction(invoiceId: string, paymentIntentId: string) {\n    try {\n        const updatedInvoice = await apiFetch(`/invoices/${invoiceId}/confirm-payment`, {\n            method: 'POST',\n            body: JSON.stringify({ paymentIntentId }),\n        });\n        revalidatePath(`/dashboard/invoices/${invoiceId}`);\n        revalidatePath('/dashboard/invoices');\n        revalidatePath('/dashboard/payments');\n        return { success: true, message: 'Payment confirmed successfully!', data: updatedInvoice };\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to confirm payment.' };\n    }\n}\n\nexport async function createCheckoutSessionAction(priceId: string) {\n    try {\n        const result = await apiFetch('/subscriptions/create-checkout-session', {\n            method: 'POST',\n            body: JSON.stringify({ priceId }),\n        });\n        if (result.url) {\n            redirect(result.url);\n        } else {\n            return { success: false, error: 'Could not create checkout session.' };\n        }\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to create checkout session.' };\n    }\n}\n\nexport async function createPortalSessionAction() {\n    try {\n        const result = await apiFetch('/subscriptions/create-portal-session', {\n            method: 'POST'\n        });\n        if (result.url) {\n            redirect(result.url);\n        } else {\n            return { success: false, error: 'Could not create portal session.' };\n        }\n    } catch (error) {\n        return { success: false, error: error instanceof Error ? error.message : 'Failed to create portal session.' };\n    }\n}\n\n\n// --- AI Actions ---\n\nasync function checkAiUsageLimit() {\n    const userResult = await getUserAction();\n    if (!userResult.success) {\n        throw new Error('Could not identify user. Please log in again.');\n    }\n    const user = userResult.data;\n    const limits = planLimits[user.plan as keyof typeof planLimits] || planLimits.free;\n\n    if (user.aiRequestCount >= limits.aiRequests) {\n        throw new Error(`You have reached your monthly limit of ${limits.aiRequests} AI requests. Please upgrade your plan.`);\n    }\n}\n\nasync function incrementAiUsage() {\n    try {\n        await apiFetch('/users/me/increment-ai', { method: 'PUT' });\n        revalidatePath('/dashboard/settings');\n    } catch (error) {\n        console.error(\"Failed to increment AI usage count:\", error);\n        // We don't throw here to not fail the main operation, but we log the error.\n    }\n}\n\nexport async function getFinancialInsightsAction() {\n  try {\n    await checkAiUsageLimit();\n\n    const [invoicesResult, paymentsResult] = await Promise.all([\n      getInvoicesAction(),\n      getPaymentsAction(),\n    ]);\n\n    if (!invoicesResult.success || !paymentsResult.success) {\n      throw new Error('Failed to fetch financial data for analysis.');\n    }\n\n    const insights = await generateFinancialInsights({\n      invoiceData: JSON.stringify(invoicesResult.data),\n      paymentData: JSON.stringify(paymentsResult.data),\n    });\n\n    await incrementAiUsage();\n    return { success: true, data: insights };\n  } catch (error) {\n    console.error('Error generating financial insights:', error);\n    const message = error instanceof Error ? error.message : 'Failed to generate financial insights.';\n    return { success: false, error: message };\n  }\n}\n\nexport async function generateInvoiceFromTextAction(text: string) {\n  try {\n    await checkAiUsageLimit();\n    const result = await generateInvoiceFromText(text);\n    await incrementAiUsage();\n    return { success: true, data: result };\n  } catch (error) {\n    console.error('Error generating invoice from text:', error);\n    const message = error instanceof Error ? error.message : 'Failed to generate invoice from text.';\n    return { success: false, error: message };\n  }\n}\n\nexport async function calculateTaxAction(address: string, subtotal: number) {\n  try {\n    await checkAiUsageLimit();\n    const result = await calculateTax({ address, subtotal });\n    await incrementAiUsage();\n    return { success: true, data: result };\n  } catch (error) {\n    console.error('Error calculating tax:', error);\n    const message = error instanceof Error ? error.message : 'Failed to calculate tax with AI.';\n    return { success: false, error: message };\n  }\n}\n"],"names":[],"mappings":";;;;;;IA8UsB,8BAAA,WAAA,GAAA,CAAA,GAAA,sNAAA,CAAA,wBAAA,EAAA,8CAAA,sNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,sNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/billing/pricing-card.tsx"],"sourcesContent":["\n'use client'\n\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Check } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { createCheckoutSessionAction } from \"@/app/actions\";\nimport { useTransition } from \"react\";\n\ninterface Plan {\n    name: string;\n    description: string;\n    price: string;\n    priceId: string;\n    features: string[];\n    isPopular?: boolean;\n}\n\ninterface PricingCardProps {\n    plan: Plan;\n    isCurrentPlan: boolean;\n}\n\nexport default function PricingCard({ plan, isCurrentPlan }: PricingCardProps) {\n    const [isPending, startTransition] = useTransition();\n\n    const handleSubscribe = () => {\n        if (!plan.priceId) return;\n        startTransition(async () => {\n            await createCheckoutSessionAction(plan.priceId);\n        });\n    };\n\n    return (\n        <Card className={cn(\"flex flex-col\", plan.isPopular && \"border-primary shadow-lg\", isCurrentPlan && \"ring-2 ring-primary\")}>\n            <CardHeader className=\"relative\">\n                {plan.isPopular && (\n                    <div className=\"absolute top-0 -translate-y-1/2 rounded-full bg-primary px-4 py-1 text-sm font-semibold text-primary-foreground\">\n                        Most Popular\n                    </div>\n                )}\n                <CardTitle className=\"font-headline text-2xl\">{plan.name}</CardTitle>\n                <CardDescription>{plan.description}</CardDescription>\n            </CardHeader>\n            <CardContent className=\"flex-grow space-y-6\">\n                <div className=\"flex items-baseline gap-2\">\n                    <span className=\"text-4xl font-bold font-headline\">{plan.price}</span>\n                    { plan.price !== '$0' && <span className=\"text-muted-foreground\">/ month</span> }\n                </div>\n                <ul className=\"space-y-3\">\n                    {plan.features.map((feature) => (\n                        <li key={feature} className=\"flex items-center gap-2 text-sm\">\n                            <Check className=\"h-5 w-5 text-green-500\" />\n                            <span>{feature}</span>\n                        </li>\n                    ))}\n                </ul>\n            </CardContent>\n            <CardFooter>\n                 {isCurrentPlan ? (\n                    <Button className=\"w-full\" disabled>\n                        Current Plan\n                    </Button>\n                ) : (\n                    <Button \n                        className=\"w-full\" \n                        variant={plan.isPopular ? \"default\" : \"outline\"}\n                        onClick={handleSubscribe}\n                        disabled={isPending || !plan.priceId}\n                    >\n                        {isPending ? 'Redirecting...' : 'Choose Plan'}\n                    </Button>\n                )}\n            </CardFooter>\n        </Card>\n    );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;AAuBe,SAAS,YAAY,EAAE,IAAI,EAAE,aAAa,EAAoB;IACzE,MAAM,CAAC,WAAW,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,gBAAa,AAAD;IAEjD,MAAM,kBAAkB;QACpB,IAAI,CAAC,KAAK,OAAO,EAAE;QACnB,gBAAgB;YACZ,MAAM,CAAA,GAAA,kJAAA,CAAA,8BAA2B,AAAD,EAAE,KAAK,OAAO;QAClD;IACJ;IAEA,qBACI,8OAAC,gIAAA,CAAA,OAAI;QAAC,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB,KAAK,SAAS,IAAI,4BAA4B,iBAAiB;;0BAChG,8OAAC,gIAAA,CAAA,aAAU;gBAAC,WAAU;;oBACjB,KAAK,SAAS,kBACX,8OAAC;wBAAI,WAAU;kCAAkH;;;;;;kCAIrI,8OAAC,gIAAA,CAAA,YAAS;wBAAC,WAAU;kCAA0B,KAAK,IAAI;;;;;;kCACxD,8OAAC,gIAAA,CAAA,kBAAe;kCAAE,KAAK,WAAW;;;;;;;;;;;;0BAEtC,8OAAC,gIAAA,CAAA,cAAW;gBAAC,WAAU;;kCACnB,8OAAC;wBAAI,WAAU;;0CACX,8OAAC;gCAAK,WAAU;0CAAoC,KAAK,KAAK;;;;;;4BAC5D,KAAK,KAAK,KAAK,sBAAQ,8OAAC;gCAAK,WAAU;0CAAwB;;;;;;;;;;;;kCAErE,8OAAC;wBAAG,WAAU;kCACT,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC,wBAChB,8OAAC;gCAAiB,WAAU;;kDACxB,8OAAC,oMAAA,CAAA,QAAK;wCAAC,WAAU;;;;;;kDACjB,8OAAC;kDAAM;;;;;;;+BAFF;;;;;;;;;;;;;;;;0BAOrB,8OAAC,gIAAA,CAAA,aAAU;0BACL,8BACE,8OAAC,kIAAA,CAAA,SAAM;oBAAC,WAAU;oBAAS,QAAQ;8BAAC;;;;;yCAIpC,8OAAC,kIAAA,CAAA,SAAM;oBACH,WAAU;oBACV,SAAS,KAAK,SAAS,GAAG,YAAY;oBACtC,SAAS;oBACT,UAAU,aAAa,CAAC,KAAK,OAAO;8BAEnC,YAAY,mBAAmB;;;;;;;;;;;;;;;;;AAMxD","debugId":null}},
    {"offset": {"line": 263, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-client-wrapper.ts"],"sourcesContent":["// This file must be bundled in the app's client layer, it shouldn't be directly\n// imported by the server.\n\nexport { callServer } from 'next/dist/client/app-call-server'\nexport { findSourceMapURL } from 'next/dist/client/app-find-source-map-url'\n\n// A noop wrapper to let the Flight client create the server reference.\n// See also: https://github.com/facebook/react/pull/26632\n// Since we're using the Edge build of Flight client for SSR [1], here we need to\n// also use the same Edge build to create the reference. For the client bundle,\n// we use the default and let Webpack to resolve it to the correct version.\n// 1: https://github.com/vercel/next.js/blob/16eb80b0b0be13f04a6407943664b5efd8f3d7d0/packages/next/src/server/app-render/use-flight-response.tsx#L24-L26\nexport const createServerReference = (\n  (!!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')) as typeof import('react-server-dom-webpack/client')\n).createServerReference\n"],"names":["callServer","createServerReference","findSourceMapURL","process","env","NEXT_RUNTIME","require"],"mappings":"AAAA,gFAAgF;AAChF,0BAA0B;;;;;;;;;;;;;;;;;IAEjBA,UAAU,EAAA;eAAVA,eAAAA,UAAU;;IASNC,qBAAqB,EAAA;eAArBA;;IARJC,gBAAgB,EAAA;eAAhBA,qBAAAA,gBAAgB;;;+BADE;qCACM;AAQ1B,MAAMD,wBACV,CAAA,CAAC,CAACE,QAAQC,GAAG,CAACC,YAAY,GAEvBC,QAAQ,0CAERA,QAAQ,8JAAiC,EAC7CL,qBAAqB","ignoreList":[0],"debugId":null}}]
}